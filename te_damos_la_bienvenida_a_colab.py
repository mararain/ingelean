# -*- coding: utf-8 -*-
"""Te damos la bienvenida a Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

# ðŸ“¦ Paso 1: Instalar librerÃ­as necesarias
!pip install transformers datasets torch scikit-learn openpyxl python-telegram-bot nest_asyncio


# ðŸ“š Paso 2: Importar librerÃ­as
import pandas as pd
import torch
import random
import nest_asyncio
import asyncio
from sklearn.preprocessing import LabelEncoder
from datasets import Dataset
from transformers import DistilBertTokenizerFast, DistilBertForSequenceClassification, Trainer, TrainingArguments
from telegram.ext import ApplicationBuilder, MessageHandler, ContextTypes, filters
from telegram import Update
from datetime import datetime, timedelta


nest_asyncio.apply()


# â° Registro de Ãºltima interacciÃ³n
ultimo_mensaje_usuario = {}


# ðŸ“‚ Paso 3: Subir archivo de preguntas
def subir_archivo():
    from google.colab import files
    uploaded = files.upload()
    return next(iter(uploaded))


filename = subir_archivo()
df = pd.read_excel(filename)
df = df.dropna(subset=["Pregunta", "CategorÃ­a", "Respuesta"])
df["Pregunta"] = df["Pregunta"].str.lower()


# ðŸ§  Paso 4: Preparar los datos
label_encoder = LabelEncoder()
df["label"] = label_encoder.fit_transform(df["CategorÃ­a"])


tokenizer = DistilBertTokenizerFast.from_pretrained("distilbert-base-uncased")
dataset = Dataset.from_pandas(df[["Pregunta", "label"]])


def tokenize_function(example):
    return tokenizer(example["Pregunta"], padding="max_length", truncation=True)


tokenized_dataset = dataset.map(tokenize_function, batched=True)


# ðŸ§  Paso 5: Cargar y entrenar modelo
model = DistilBertForSequenceClassification.from_pretrained(
    "distilbert-base-uncased",
    num_labels=len(label_encoder.classes_)
)


training_args = TrainingArguments(
    output_dir="./results",
    per_device_train_batch_size=8,
    num_train_epochs=3,
    logging_steps=10,
    save_steps=50,
    save_total_limit=1,
    learning_rate=2e-5,
    weight_decay=0.01,
)


trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=tokenized_dataset,
    tokenizer=tokenizer
)


trainer.train()


# ðŸ“˜ Diccionario de respuestas
respuestas_dict = df.groupby("CategorÃ­a")["Respuesta"].apply(list).to_dict()


# ðŸ” FunciÃ³n de predicciÃ³n
def predecir_intencion_transformers(pregunta):
    inputs = tokenizer(pregunta.lower(), return_tensors="pt", truncation=True, padding=True)
    outputs = model(**inputs)
    prediction = torch.argmax(outputs.logits, dim=1).item()
    return label_encoder.inverse_transform([prediction])[0]


# ðŸ“‹ MenÃº principal de servicios
menu_principal = """
ðŸ“‹ *MENÃš DE SERVICIOS DISPONIBLES*


1ï¸âƒ£ *Inteligencia Artificial (IA)*
   â”œâ”€ 1.1 IntegraciÃ³n de IA en procesos ya existentes
   â”œâ”€ 1.2 AnÃ¡lisis de datos histÃ³ricos y de sensores
   â”œâ”€ 1.3 OptimizaciÃ³n de procesos (fallas, eficiencia)
   â”œâ”€ 1.4 Estudio de retorno de inversiÃ³n (ROI)
   â”œâ”€ 1.5 AplicaciÃ³n en agroindustria, manufactura, logÃ­stica
   â”œâ”€ 1.6 IA para empresas grandes y PYMES
   â”œâ”€ 1.7 Machine Learning en procesos industriales
   â”œâ”€ 1.8 AnÃ¡lisis de datos con IA
   â””â”€ 1.9 Cloud computing para IA


ðŸ–¥ï¸ *Software*
   â”œâ”€ 2.1 Desarrollo de software desde cero
   â”œâ”€ 2.2 AdaptaciÃ³n e integraciÃ³n de software
   â”œâ”€ 2.3 Interfaces personalizadas y prototipos
   â”œâ”€ 2.4 CapacitaciÃ³n y compatibilidad con sistemas
   â”œâ”€ 2.5 Desarrollo de Apps mÃ³viles industriales
   â”œâ”€ 2.6 ProgramaciÃ³n y anÃ¡lisis en la nube
   â””â”€ 2.7 Sistemas de monitoreo y reportes (CSV, PDF, XLS)


ðŸ› ï¸ *Hardware*
   â”œâ”€ 3.1 FabricaciÃ³n de hardware especializado
   â”œâ”€ 3.2 Dispositivos embebidos y dataloggers
   â”œâ”€ 3.3 Sensores para temperatura, humedad, etc.
   â”œâ”€ 3.4 IntegraciÃ³n hardware-software
   â”œâ”€ 3.5 Desarrollo de tableros elÃ©ctricos
   â””â”€ 3.6 Levantamiento de planos elÃ©ctricos industriales


âš™ï¸ *AutomatizaciÃ³n Industrial*
   â”œâ”€ 4.1 Sistemas PLC, SCADA, HMI
   â”œâ”€ 4.2 AutomatizaciÃ³n con sensores y robÃ³tica
   â”œâ”€ 4.3 Soluciones escalables para empresas
   â”œâ”€ 4.4 Seguridad industrial y control elÃ©ctrico
   â”œâ”€ 4.5 IntegraciÃ³n M2M y telemetrÃ­a
   â””â”€ 4.6 Monitoreo remoto y servidores de procesos


ðŸ”§ *Mantenimiento*
   â”œâ”€ 5.1 Mantenimiento preventivo, correctivo y predictivo
   â”œâ”€ 5.2 DiagnÃ³stico, reparaciÃ³n y calibraciÃ³n
   â”œâ”€ 5.3 Soporte tÃ©cnico 24/7 y garantÃ­as
   â”œâ”€ 5.4 CapacitaciÃ³n del equipo operativo
   â”œâ”€ 5.5 Planes de pago y tarifas regionales
   â”œâ”€ 5.6 GestiÃ³n postventa y mejora continua
   â””â”€ 5.7 TelemetrÃ­a para mantenimiento proactivo
"""


# ðŸ§¾ FunciÃ³n para mostrar el menÃº
async def mostrar_menu(update, context, username):
    mensaje_bienvenida = f"Â¡Hola {username}! ðŸ˜Š Bienvenido/a al centro de soporte. Estoy aquÃ­ para ayudarte.\n"
    await update.message.reply_text(mensaje_bienvenida)
    await update.message.reply_text(menu_principal, parse_mode="Markdown")


# ðŸ¤– Telegram Bot
LOG_FILE = "registro_interacciones_chatbot_transformers.xlsx"
usuarios_saludados = set()
usuarios_activos = {}
palabras_despedida = ["adiÃ³s", "gracias", "hasta luego", "nos vemos", "chao", "bye"]
palabras_reinicio = ["reiniciar", "empezar de nuevo", "volver a empezar", "menÃº", "menu"]


# ðŸ” VerificaciÃ³n de inactividad
async def verificar_inactividad():
    while True:
        ahora = datetime.now()
        for user, ultimo in list(usuarios_activos.items()):
            if (ahora - ultimo) > timedelta(minutes=5):
                if user in usuarios_saludados:
                    usuarios_saludados.remove(user)
                usuarios_activos.pop(user)
        await asyncio.sleep(60)


# ðŸ“Œ FunciÃ³n principal del bot
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_message = update.message.text.lower()
    username = update.effective_user.username or update.effective_user.first_name
    respuesta = ""


    usuarios_activos[username] = datetime.now()


    if any(p in user_message for p in palabras_reinicio):
        if username in usuarios_saludados:
            usuarios_saludados.remove(username)
        await mostrar_menu(update, context, username)
        return


    if username not in usuarios_saludados:
        usuarios_saludados.add(username)
        await mostrar_menu(update, context, username)
        return


    if any(palabra in user_message for palabra in palabras_despedida):
        respuesta += "Â¡Gracias por comunicarte con nosotros! Que tengas un excelente dÃ­a. ðŸŒŸðŸ‘‹, para mas informaciÃ³n ingresa a nuestra pagina web: https://ingelean.com/#service-page"
        if username in usuarios_saludados:
            usuarios_saludados.remove(username)
        await update.message.reply_text(respuesta)
        return


    try:
        intencion = predecir_intencion_transformers(user_message)
        posibles_respuestas = respuestas_dict.get(intencion, [])
        respuesta += random.choice(posibles_respuestas) if posibles_respuestas else "Estoy entrenando para darte mejores respuestas pronto. ðŸ˜Š"
    except Exception:
        respuesta += "Lo siento, no entendÃ­ tu pregunta. Â¿Puedes reformularla?"


    await update.message.reply_text(respuesta)


    log = {
        "Usuario": username,
        "Pregunta": update.message.text,
        "Respuesta": respuesta,
        "Fecha": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }


    try:
        historial = pd.read_excel(LOG_FILE)
        historial = pd.concat([historial, pd.DataFrame([log])], ignore_index=True)
    except FileNotFoundError:
        historial = pd.DataFrame([log])
    historial.to_excel(LOG_FILE, index=False)


# ðŸš€ Lanzar el bot
TOKEN = "8341715432:AAGiaMU9uC1ouieKl2P7FCPlOSDQ-hIaFPI"  # ReemplÃ¡zalo por el tuyo
app = ApplicationBuilder().token(TOKEN).build()
app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))


# ðŸ§  Iniciar verificaciÃ³n de inactividad
async def iniciar_bot():
    print("ðŸ¤– Bot activo en Telegram. Â¡Habla con Ã©l!")
    asyncio.create_task(verificar_inactividad())
    await app.run_polling()


await iniciar_bot()