# -*- coding: utf-8 -*-
"""Te damos la bienvenida a Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

# 📦 Paso 1: Instalar librerías necesarias
!pip install transformers datasets torch scikit-learn openpyxl python-telegram-bot nest_asyncio


# 📚 Paso 2: Importar librerías
import pandas as pd
import torch
import random
import nest_asyncio
import asyncio
from sklearn.preprocessing import LabelEncoder
from datasets import Dataset
from transformers import DistilBertTokenizerFast, DistilBertForSequenceClassification, Trainer, TrainingArguments
from telegram.ext import ApplicationBuilder, MessageHandler, ContextTypes, filters
from telegram import Update
from datetime import datetime, timedelta


nest_asyncio.apply()


# ⏰ Registro de última interacción
ultimo_mensaje_usuario = {}


# 📂 Paso 3: Subir archivo de preguntas
def subir_archivo():
    from google.colab import files
    uploaded = files.upload()
    return next(iter(uploaded))


filename = subir_archivo()
df = pd.read_excel(filename)
df = df.dropna(subset=["Pregunta", "Categoría", "Respuesta"])
df["Pregunta"] = df["Pregunta"].str.lower()


# 🧠 Paso 4: Preparar los datos
label_encoder = LabelEncoder()
df["label"] = label_encoder.fit_transform(df["Categoría"])


tokenizer = DistilBertTokenizerFast.from_pretrained("distilbert-base-uncased")
dataset = Dataset.from_pandas(df[["Pregunta", "label"]])


def tokenize_function(example):
    return tokenizer(example["Pregunta"], padding="max_length", truncation=True)


tokenized_dataset = dataset.map(tokenize_function, batched=True)


# 🧠 Paso 5: Cargar y entrenar modelo
model = DistilBertForSequenceClassification.from_pretrained(
    "distilbert-base-uncased",
    num_labels=len(label_encoder.classes_)
)


training_args = TrainingArguments(
    output_dir="./results",
    per_device_train_batch_size=8,
    num_train_epochs=3,
    logging_steps=10,
    save_steps=50,
    save_total_limit=1,
    learning_rate=2e-5,
    weight_decay=0.01,
)


trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=tokenized_dataset,
    tokenizer=tokenizer
)


trainer.train()


# 📘 Diccionario de respuestas
respuestas_dict = df.groupby("Categoría")["Respuesta"].apply(list).to_dict()


# 🔍 Función de predicción
def predecir_intencion_transformers(pregunta):
    inputs = tokenizer(pregunta.lower(), return_tensors="pt", truncation=True, padding=True)
    outputs = model(**inputs)
    prediction = torch.argmax(outputs.logits, dim=1).item()
    return label_encoder.inverse_transform([prediction])[0]


# 📋 Menú principal de servicios
menu_principal = """
📋 *MENÚ DE SERVICIOS DISPONIBLES*


1️⃣ *Inteligencia Artificial (IA)*
   ├─ 1.1 Integración de IA en procesos ya existentes
   ├─ 1.2 Análisis de datos históricos y de sensores
   ├─ 1.3 Optimización de procesos (fallas, eficiencia)
   ├─ 1.4 Estudio de retorno de inversión (ROI)
   ├─ 1.5 Aplicación en agroindustria, manufactura, logística
   ├─ 1.6 IA para empresas grandes y PYMES
   ├─ 1.7 Machine Learning en procesos industriales
   ├─ 1.8 Análisis de datos con IA
   └─ 1.9 Cloud computing para IA


🖥️ *Software*
   ├─ 2.1 Desarrollo de software desde cero
   ├─ 2.2 Adaptación e integración de software
   ├─ 2.3 Interfaces personalizadas y prototipos
   ├─ 2.4 Capacitación y compatibilidad con sistemas
   ├─ 2.5 Desarrollo de Apps móviles industriales
   ├─ 2.6 Programación y análisis en la nube
   └─ 2.7 Sistemas de monitoreo y reportes (CSV, PDF, XLS)


🛠️ *Hardware*
   ├─ 3.1 Fabricación de hardware especializado
   ├─ 3.2 Dispositivos embebidos y dataloggers
   ├─ 3.3 Sensores para temperatura, humedad, etc.
   ├─ 3.4 Integración hardware-software
   ├─ 3.5 Desarrollo de tableros eléctricos
   └─ 3.6 Levantamiento de planos eléctricos industriales


⚙️ *Automatización Industrial*
   ├─ 4.1 Sistemas PLC, SCADA, HMI
   ├─ 4.2 Automatización con sensores y robótica
   ├─ 4.3 Soluciones escalables para empresas
   ├─ 4.4 Seguridad industrial y control eléctrico
   ├─ 4.5 Integración M2M y telemetría
   └─ 4.6 Monitoreo remoto y servidores de procesos


🔧 *Mantenimiento*
   ├─ 5.1 Mantenimiento preventivo, correctivo y predictivo
   ├─ 5.2 Diagnóstico, reparación y calibración
   ├─ 5.3 Soporte técnico 24/7 y garantías
   ├─ 5.4 Capacitación del equipo operativo
   ├─ 5.5 Planes de pago y tarifas regionales
   ├─ 5.6 Gestión postventa y mejora continua
   └─ 5.7 Telemetría para mantenimiento proactivo
"""


# 🧾 Función para mostrar el menú
async def mostrar_menu(update, context, username):
    mensaje_bienvenida = f"¡Hola {username}! 😊 Bienvenido/a al centro de soporte. Estoy aquí para ayudarte.\n"
    await update.message.reply_text(mensaje_bienvenida)
    await update.message.reply_text(menu_principal, parse_mode="Markdown")


# 🤖 Telegram Bot
LOG_FILE = "registro_interacciones_chatbot_transformers.xlsx"
usuarios_saludados = set()
usuarios_activos = {}
palabras_despedida = ["adiós", "gracias", "hasta luego", "nos vemos", "chao", "bye"]
palabras_reinicio = ["reiniciar", "empezar de nuevo", "volver a empezar", "menú", "menu"]


# 🔁 Verificación de inactividad
async def verificar_inactividad():
    while True:
        ahora = datetime.now()
        for user, ultimo in list(usuarios_activos.items()):
            if (ahora - ultimo) > timedelta(minutes=5):
                if user in usuarios_saludados:
                    usuarios_saludados.remove(user)
                usuarios_activos.pop(user)
        await asyncio.sleep(60)


# 📌 Función principal del bot
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_message = update.message.text.lower()
    username = update.effective_user.username or update.effective_user.first_name
    respuesta = ""


    usuarios_activos[username] = datetime.now()


    if any(p in user_message for p in palabras_reinicio):
        if username in usuarios_saludados:
            usuarios_saludados.remove(username)
        await mostrar_menu(update, context, username)
        return


    if username not in usuarios_saludados:
        usuarios_saludados.add(username)
        await mostrar_menu(update, context, username)
        return


    if any(palabra in user_message for palabra in palabras_despedida):
        respuesta += "¡Gracias por comunicarte con nosotros! Que tengas un excelente día. 🌟👋, para mas información ingresa a nuestra pagina web: https://ingelean.com/#service-page"
        if username in usuarios_saludados:
            usuarios_saludados.remove(username)
        await update.message.reply_text(respuesta)
        return


    try:
        intencion = predecir_intencion_transformers(user_message)
        posibles_respuestas = respuestas_dict.get(intencion, [])
        respuesta += random.choice(posibles_respuestas) if posibles_respuestas else "Estoy entrenando para darte mejores respuestas pronto. 😊"
    except Exception:
        respuesta += "Lo siento, no entendí tu pregunta. ¿Puedes reformularla?"


    await update.message.reply_text(respuesta)


    log = {
        "Usuario": username,
        "Pregunta": update.message.text,
        "Respuesta": respuesta,
        "Fecha": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }


    try:
        historial = pd.read_excel(LOG_FILE)
        historial = pd.concat([historial, pd.DataFrame([log])], ignore_index=True)
    except FileNotFoundError:
        historial = pd.DataFrame([log])
    historial.to_excel(LOG_FILE, index=False)


# 🚀 Lanzar el bot
TOKEN = "8341715432:AAGiaMU9uC1ouieKl2P7FCPlOSDQ-hIaFPI"  # Reemplázalo por el tuyo
app = ApplicationBuilder().token(TOKEN).build()
app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))


# 🧠 Iniciar verificación de inactividad
async def iniciar_bot():
    print("🤖 Bot activo en Telegram. ¡Habla con él!")
    asyncio.create_task(verificar_inactividad())
    await app.run_polling()


await iniciar_bot()